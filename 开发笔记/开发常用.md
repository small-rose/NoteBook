


## 开发常用

http://editor.md.ipandao.com/examples/full.html

环境变量
-------------------------
CLASSPATH
```
.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\rt.jar%JAVA_HOME%\lib\tools.jar;%ANT_HOME%\lib;%JMETER_HOME\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;
```

PATH:

```
%JAVA_HOME%\bin;

%MAVEN_HOME%\bin;

%ANT_HOME%\bin;

d:\subversion\bin;
```


idea 自带maven
```
D:\dev-tools\JetBrains\IntelliJ IDEA 2020.1\plugins\maven\lib\maven3\conf
```



hosts
----------------------------------
C:\Windows\System32\drivers\etc



IDEA 插件官网
----------------------------------
https://plugins.jetbrains.com/idea
常用插件

- Jrebel --热部署

- GenerateAllSetter --对象赋值插件

- generateO2O -- 对象快速赋值

- Free-idea-mybatis --mapper-xml

- intellij-mybaitslog --开源

- Json Parser -- json解析

- Mybatis-log-plugin --mybatis 日志

- FindBugs -- 找bug

- CodeGlance -- 编辑区缩略图插件

- GrepConsole -- 控制台速查

- Thief-Book -- 看书

- TranslationPlugin -- 翻译

- IdeaJad --反编译

- SVNLable -- SVN提交人和时间显示

- background Image Plus + 壁纸

- cota AI


JRebel
--------------------------------------------------

生成 GUID 的网址
https://www.guidgen.com/

用这个网址 + 生成的 GUID 激活
https://jrebel.qekang.com/

例如:
https://jrebel.qekang.com/cb2546bb-9d43-4115-bf4b-10539349efed


设置离线模式 来防止失效
File -> Settings -> JRebel -> [Work offline]按钮


redis 下载

http://download.redis.io/releases/

redis 6  要求gcc的版本高于5

JPS
------------------
命令用法: 
```bash
jps [options] [hostid]
```
参数说明：

- options:命令选项，用来对输出格式进行控制

- hostid:指定特定主机，可以是ip地址和域名, 也可以指定具体协议，端口。

```
[protocol:][[//]hostname][:port][/servername]
```

功能描述: jps是用于查看有权访问的hotspot虚拟机的进程. 当未指定hostid时，默认查看本机jvm进程，否者查看指定的hostid机器上的jvm进程，此时hostid所指机器必须开启jstatd服务。 jps可以列出jvm进程lvmid，主类类名，main函数参数, jvm参数，jar名称等信息。

options 命令选项及功能:

没添加option的时候，默认列出VM标示符号和简单的class或jar名称.如下:

- `-p` : 仅仅显示VM 标示，不显示jar,class, main参数等信息.

- `-m` : 输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数

- `-l` : 输出应用程序主类完整package名称或jar完整名称.

- `-v` : 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数

- `-V` : 输出通过.hotsportrc或-XX:Flags=<filename>指定的jvm参数

- `-Joption` : 传递参数到javac 调用的java lancher.


Springboot 停止
-------------------
Spring Boot提供了2种优雅关闭进程的方式：
    - 基于管理端口关闭进程
    - 基于系统服务方式关闭进程


#### 基于端口

基于管理端口方式实现进程关闭实际上是模块spring-boot-actuator提供的功能。

添加依赖

```XML
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

添加配置

```YAML
management:
  server:
    address: 127.0.0.1
    port: 8000
  endpoint:
    shutdown:
      enabled: true
  endpoints:
    web:
      base-path: /ops
      path-mapping:
        - shutdown: shutdown
      exposure:
        include: info,health,shutdown
```

启动Spring Boot应用，通过调用`POST http://localhost:8000/ops/shutdown`即可关闭进程。

```bash
curl -X POST http://127.0.0.1:8000/ops/shutdown --connect-timeout 3 --max-time 5
```

一般整合shell 脚本, pname 指进程名称。

```bash
#!/bin/bash
# 先通过管理端口关闭进程
curl -X POST http://127.0.0.1:8000/ops/shutdown --connect-timeout 3 --max-time 5

# 再次通过名称检查进程是否被成功停止
count=`ps -ef |grep pname |grep -v "grep" |wc -l`
if [ $count -gt 0 ]; then
    if [ -f "$pid_file" ]; then
        # 如果存在进程ID文件，则读取进程ID使用信号量通知方式关闭进程
        pid=`cat $pid_file`
        kill -15 $pid
    else
        # 通过名称方式查找到进程ID，使用信号量通知方式关闭进程
        pid=`ps -ef |grep pname |grep -v "grep"| awk '{print $2}'`
        kill -15 $pid
    fi
fi
```

完整版：

```bash
#!/bin/bash
#这里可替换为你自己的执行程序，其他代码无需更改
APP_NAME=springboot-demo-1.0.0.jar
  
#使用说明，用来提示输入参数
usage() {
    echo "Usage: sh 脚本名.sh [start|stop|restart|status]"
    exit 1
}
  
#检查程序是否在运行
is_exist(){
  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '{print $2}' `
  #如果不存在返回1，存在返回0    
  if [ -z "${pid}" ]; then
   return 1
  else
    return 0
  fi
}
  
#启动方法
start(){
  is_exist
  if [ $? -eq "0" ]; then
    echo "${APP_NAME} is already running. pid=${pid} ."
  else
    nohup java -jar /mnt/ssd1/project/websocket/$APP_NAME > /mnt/ssd1/project/websocket/websocketserverlog.file 2>&1 &
    echo "${APP_NAME} start success"
  fi
}
  
#停止方法
stop(){
  is_exist
  if [ $? -eq "0" ]; then
    kill -9 $pid
  else
    echo "${APP_NAME} is not running"
  fi 
}
  
#输出运行状态
status(){
  is_exist
  if [ $? -eq "0" ]; then
    echo "${APP_NAME} is running. Pid is ${pid}"
  else
    echo "${APP_NAME} is NOT running."
  fi
}
  
#重启
restart(){
  stop
  start
}
  
#根据输入参数，选择执行对应方法，不输入则执行使用说明
case "$1" in
  "start")
    start
    ;;
  "stop")
    stop
    ;;
  "status")
    status
    ;;
  "restart")
    restart
    ;;
  *)
    usage
    ;;
esac
```


将jar包做成系统服务

其次，将打包好的应用jar包添加为系统服务（在ubuntu18.04 LTS上实现，基于systemd）

1.假设将Spring Boot应用安装到 `/var/companyApp` 目录下：将上述打包好的jar包拷贝到`/var/companyApp`（目录不存在，手动创建）

2.在 `/etc/systemd/system` 下添加指定名称的系统服务： `myapp.service`，内容如下：

```
[Unit]
Description=myapp
After=syslog.target

[Service]
User=root  ## 注意：这里配置的是将来启动该服务的Linux系统用户名，影响权限
ExecStart=/var/companyApp/myapp.jar
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target
```

3.启动服务

```bash
$ sudo systemctl enable myapp.service
$ sudo systemctl start myapp.service
```
如果需要查看应用启动日志，请执行：$ journalctl -f。

#### 通过系统服务方式停止进程

Spring Boot支持直接将打包好的可执行jar包以系统服务方式运行，具体实现方式如下所述。

首先，将应用打包为完全可执行的jar包。

    Maven打包配配置
```XML
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <!-- 这个配置非常重要，使打包好的jar包具备可执行权限-->
        <executable>true</executable>
    </configuration>
</plugin>
```
Gradle打包配置
```
bootJar {
    launchScript()
}
```

其次，将打包好的应用jar包添加为系统服务



MAVEN
-------------------

### 骨架原型

maven提供的41个骨架原型分别是：

1: appfuse-basic-jsf (创建一个基于Hibernate，Spring和JSF的Web应用程序的原型) 
2: appfuse-basic-spring(创建一个基于Hibernate，Spring和Spring MVC的Web应用程序的原型) 
3: appfuse-basic-struts(创建一个基于Hibernate，Spring和Struts 2的Web应用程序的原型) 
4: appfuse-basic-tapestry(创建一个基于Hibernate，Spring 和 Tapestry 4的Web应用程序的原型) 
5: appfuse-core(创建一个基于Hibernate，Spring 和 XFire的jar应用程序的原型) 
6: appfuse-modular-jsf(创建一个基于Hibernate，Spring和JSF的模块化应用原型) 
7: appfuse-modular-spring(创建一个基于Hibernate, Spring 和 Spring MVC 的模块化应用原型) 
8: appfuse-modular-struts(创建一个基于Hibernate, Spring 和 Struts 2 的模块化应用原型) 
9: appfuse-modular-tapestry (创建一个基于 Hibernate, Spring 和 Tapestry 4 的模块化应用原型) 
10: maven-archetype-j2ee-simple(一个简单的J2EE的Java应用程序) 
11: maven-archetype-marmalade-mojo(一个Maven的 插件开发项目 using marmalade) 
12: maven-archetype-mojo(一个Maven的Java插件开发项目) 
13: maven-archetype-portlet(一个简单的portlet应用程序) 
14: maven-archetype-profiles() 
15:maven-archetype-quickstart() 
16: maven-archetype-site-simple(简单的网站生成项目) 
17: maven-archetype-site(更复杂的网站项目) 
18:maven-archetype-webapp(一个简单的Java Web应用程序) 
19: jini-service-archetype(Archetype for Jini service project creation) 
20: softeu-archetype-seam(JSF+Facelets+Seam Archetype) 
21: softeu-archetype-seam-simple(JSF+Facelets+Seam (无残留) 原型) 
22: softeu-archetype-jsf(JSF+Facelets 原型) 
23: jpa-maven-archetype(JPA 应用程序) 
24: spring-osgi-bundle-archetype(Spring-OSGi 原型) 
25: confluence-plugin-archetype(Atlassian 聚合插件原型) 
26: jira-plugin-archetype(Atlassian JIRA 插件原型) 
27: maven-archetype-har(Hibernate 存档) 
28: maven-archetype-sar(JBoss 服务存档) 
29: wicket-archetype-quickstart(一个简单的Apache Wicket的项目) 
30: scala-archetype-simple(一个简单的scala的项目) 
31: lift-archetype-blank(一个 blank/empty liftweb 项目) 
32: lift-archetype-basic(基本（liftweb）项目) 
33: cocoon-22-archetype-block-plain([http://cocoapacorg2/maven-plugins/]) 
34: cocoon-22-archetype-block([http://cocoapacorg2/maven-plugins/]) 
35:cocoon-22-archetype-webapp([http://cocoapacorg2/maven-plugins/]) 
36: myfaces-archetype-helloworld(使用MyFaces的一个简单的原型) 
37: myfaces-archetype-helloworld-facelets(一个使用MyFaces和Facelets的简单原型) 
38: myfaces-archetype-trinidad(一个使用MyFaces和Trinidad的简单原型) 
39: myfaces-archetype-jsfcomponents(一种使用MyFaces创建定制JSF组件的简单的原型) 
40: gmaven-archetype-basic(Groovy的基本原型) 
41: gmaven-archetype-mojo(Groovy mojo 原型)

