---
layout: default
title: ORACLE
nav_order: 20
parent: Database
---

# ORACLE
{: .no_toc }

## TABLE of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## oracle 

Oracle 在线学习：https://livesql.oracle.com

Oracle 11g R2 在线数据库：http://sqlfiddle.com/#!4/4cc558/3

## Oralce 元数据查询

### 查表信息

```sql
-- 查用户所有的表
SELECT * FROM USER_TABLES ;
-- 查表的注释
SELECT * FROM USER_TAB_COMMENTS ;
-- 查询压缩表
SELECT * FROM USER_TABLES WHERE COMPRESSION = 'ENABLED';

-- 查用户所有的分区表（含二级分区）
SELECT * FROM USER_TAB_PARTITIONS ;
-- 查用户所有的二级分区表（仅二级分区）
SELECT * FROM USER_TABLES ;
```

查分区表相关的信息

```sql
-- 查分区表分区方式、分区字段分区数量（含一级分区和二级分区）
SELECT  X.TABLE_NAME, X.PART_TYPE, X.PART_COLUMN_NAME, X.SUBPART_TYPE, X.SUBPART_COLUMN_NAME,X.PARTITION_COUNT
FROM (
    SELECT P.TABLE_NAME, P.PARTITIONING_TYPE AS  PART_TYPE, K.COLUMN_NAME AS PART_COLUMN_NAME,
           P.SUBPARTITIONING_TYPE AS SUBPART_TYPE, SK.COLUMN_NAME AS SUBPART_COLUMN_NAME, P.PARTITION_COUNT AS PARTITION_COUNT
           --,P.OWNER
    FROM USER_PART_TABLES P INNER JOIN USER_PART_KEY_COLUMNS K ON P.TABLE_NAME = K.NAME
    LEFT JOIN USER_SUBPART_KEY_COLUMNS SK ON K.NAME = SK.NAME
) X WHERE 1=1 -- AND X.OWNER= V_OWNER  -- DBA_TABLES 需要
AND X.TABLE_NAME NOT LIKE 'BIN%';
```

### 查表的列

(1) 全部的列

```sql
-- 查表的列信息、类型长度、非空等
SELECT * FROM USER_TAB_COLUMNS ;
-- 查表的列注释
SELECT * FROM USER_COL_COMMENTS ;
```
（2）查主键列

```sql
-- 查表的列信息、类型长度、非空等
SELECT * FROM USER_TAB_COLUMNS ;
-- 查列的约束
SELECT * FROM USER_CONS_COLUMNS ;
-- 查表的主键 CONSTRINT_TYPE = 'P' 是主键
SELECT * FROM USER_CONSTRAINTS ;

-- 查表的主键
SELECT CC.TABLE_NAME, CC.CONSTRAINT_NAME, LISTAGG(CC.COLUMN_NAME,',')
    WITHIN GROUP (ORDER BY CC.TABLE_NAME, CC.COLUMN_NAME)
FROM USER_CONS_COLUMNS CC, USER_CONSTRAINTS CS
WHERE CC.CONSTRAINT_NAME = CS.CONSTRAINT_NAME
GROUP BY CC.TABLE_NAME, CC.CONSTRAINT_NAME
ORDER BY CC.TABLE_NAME, CC.CONSTRAINT_NAME
```
（3）索引列

```sql
-- 查用户索引
SELECT * FROM USER_INDEXES ;
-- 查用户索引涉及到列
SELECT * FROM USER_IND_COLUMNS ;
```

（3）特殊索引

```sql
-- 查失效索引
SELECT * FROM USER_INDEXES WHERE STATUS = 'INVALID' ;
-- 查函数索引
SELECT * FROM USER_INDEXES WHERE INDEX_TYPE like  '%FUNCTION-BASED%';
```

一次性查询

```sql
-- 查询索引
SELECT IC.TABLE_NAME, IC.INDEX_NAME, 
       LISTAGG(IC.COLUMN_NAME, ',') WITHIN GROUP (ORDER BY TABLE_NAME,INDEX_NAME, COLUMN_POSITION )
FROM USER_IND_COLUMNS IC
WHERE 1=1 AND TABLE_NAME = 'B_AUTOSTORE'
GROUP BY IC.TABLE_NAME, IC.INDEX_NAME
ORDER BY IC.INDEX_NAME, IC.INDEX_NAME
```


```sql
-- 查询表索引-含普通索引、函数索引等
SELECT T.TABLE_NAME, T.INDEX_NAME,
       LISTAGG(CASE
                   WHEN INSTR(I.INDEX_TYPE, 'FUNCTION') > 0 THEN NEWCOLUMN_NAME
                   ELSE T.COLUMN_NAME || ' ' || T.DESCEND END, ',')
               WITHIN GROUP (ORDER BY T.TABLE_NAME,T.INDEX_NAME,T.COLUMN_POSITION) AS COLUMN_NAME,
       I.INDEX_TYPE,
       I.UNIQUENESS
FROM (SELECT N.*,
             (CASE
                  WHEN INSTR(N.COLUMN_NAME, 'SYS_NC') > 0 THEN
                      (SELECT INDEX_COLUMN_EXPRESSION(E.TABLE_NAME, E.INDEX_NAME, E.COLUMN_POSITION)
                       FROM USER_IND_EXPRESSIONS E
                       WHERE E.INDEX_NAME = N.INDEX_NAME AND E.COLUMN_POSITION = N.COLUMN_POSITION)
                  ELSE N.COLUMN_NAME END) AS NEWCOLUMN_NAME
      FROM USER_IND_COLUMNS N
    WHERE N.TABLE_NAME = 'ACT_RU_CASE_EXECUTION'
    ) T, USER_INDEXES I
WHERE T.INDEX_NAME = I.INDEX_NAME
  AND T.TABLE_NAME = I.TABLE_NAME
GROUP BY T.TABLE_NAME, T.INDEX_NAME, I.INDEX_TYPE, I.UNIQUENESS
ORDER BY T.TABLE_NAME, T.INDEX_NAME ;
```


### 查存储


查表和索引的存储

```sql
--查询表及表的素引占用的存储空间 (删选大于1G的)
SELECT M.TABLE_NAME, M.TABLE_GB, M.INDEX_GB FROM (
-- 行转列-start
SELECT TABLE_NAME, TABLE_GB, INDEX_GB FROM (
-- 可查单表 START
SELECT  O.TABLE_NAME, O.SEGMENT_TYPE,  ROUND(SUM(GB), 4) AS OGB FROM (
SELECT CASE WHEN INSTR(T.SEGMENT_TYPE, 'TABLE') >0 THEN T.SEGMENT_NAME
            ELSE ( SELECT I.TABLE_NAME FROM DBA_INDEXES I WHERE I.INDEX_NAME = T.SEGMENT_NAME)
        END AS TABLE_NAME,
       CASE WHEN INSTR(T.SEGMENT_TYPE, 'TABLE') >0 THEN 'TABLE' ELSE 'INDEX' END AS SEGMENT_TYPE,
       T.PARTITION_NAME,
       T.BYTES/1024/1024/1024 AS GB
FROM DBA_SEGMENTS T
WHERE T.OWNER = 'BVIS'
AND (  t.SEGMENT_NAME = 'ZZY_SUBPART_TEST' OR T.SEGMENT_NAME IN (
        SELECT D.INDEX_NAME FROM DBA_INDEXES D WHERE D.TABLE_NAME = 'ZZY_SUBPART_TEST' )
    )
AND PARTITION_NAME = ''
AND T.SEGMENT_NAME NOT LIKE 'BIN%'
AND T.SEGMENT_TYPE IN ('TABLE','TABLE PARTITION','TABLE SUBPARTITION','INDEX','INDEX PARTITION','INDEX SUBPARTITION')
) O
WHERE 1=1 --AND O.TABLE_NAME = ''
GROUP BY O.TABLE_NAME, O.SEGMENT_TYPE, O.PARTITION_NAME
ORDER BY O.TABLE_NAME, O.SEGMENT_TYPE DESC, O.PARTITION_NAME
-- 可查单表 END
) X PIVOT (SUM(OGB) FOR SEGMENT_TYPE IN ('TABLE' AS TABLE_GB, 'INDEX' AS INDEX_GB) )
-- 行转列-end
    ) M
WHERE M.TABLE_GB > 0;
```
 
 
### 统计表数据信息

统计表、数据量、表数据存储、表索引存储

(1) 准备表

```sql
CREATE TABLE ZZY_QUERYCOUNT_TC(
    TABLE_NAME VARCHAR2(40),
    PART_TYPE VARCHAR2(20),
    PART_COLUMN_NAME VARCHAR2(40),
    SUBPART_TYPE VARCHAR2(20),
    SUBPART_COLUMN_NAME VARCHAR2(40),
    PARTITION_COUNT NUMBER(20),
    TOTAL_COUNT VARCHAR2(200),
    TBL_SIZE VARCHAR2(200),
    TBL_IDX_SIZE VARCHAR2(200),
    IF_VALID CHAR(1) DEFAULT '1',
    QUERY_CRITERIA VARCHAR2(200),
    VALUE1 VARCHAR2(200),
    VALUE2 VARCHAR2(200),
    LAST_OPDATE DATE DEFAULT SYSDATE,
    EXT1 VARCHAR2(500),
    EXT2 VARCHAR2(500)
);

COMMENT ON TABLE ZZY_QUERYCOUNT_TC IS '表信息统计';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.TABLE_NAME IS '表名称';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.PART_TYPE IS '一级分区类型';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.PART_COLUMN_NAME IS '一级分区字段';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.SUBPART_TYPE IS '二级分区类型';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.SUBPART_COLUMN_NAME IS '二级分区字段';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.PARTITION_COUNT IS '表分区数';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.TOTAL_COUNT IS '表数据记录数';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.TBL_SIZE IS '表数据存储大小,单位以查询时的SQL为准';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.TBL_IDX_SIZE IS '表索引存储大小,单位以查询时的SQL为准';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.IF_VALID IS '是否有效，1-有效;0无效';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.QUERY_CRITERIA IS '复杂查询时查询条件';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.VALUE1 IS '复杂查询时变量条件';
COMMENT ON COLUMN ZZY_QUERYCOUNT_TC.VALUE2 IS '复杂查询时变量条件';

CREATE TABLE ZZY_QUERYCOUNT_LIST_TC
(
    TABLE_NAME VARCHAR2(40),
    PART_NAME VARCHAR2(50),
    SUBPART_COUNT NUMBER(20),
    SUBPART_NAME VARCHAR2(50),
    PART_DATA_COUNT VARCHAR2(200),
    PART_TBL_SIZE VARCHAR2(200),
    PART_IDX_SIZE VARCHAR2(200),
    IF_VALID CHAR(1) DEFAULT '1',
    LAST_OPDATE DATE DEFAULT SYSDATE,
    EXT1 VARCHAR2(500),
    EXT2 VARCHAR2(500)
);

COMMENT ON TABLE ZZY_QUERYCOUNT_LIST_TC IS '分区表分区信息统计';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.TABLE_NAME IS '表名称';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.PART_NAME IS '一级分区名称';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.SUBPART_COUNT IS '一级分区数量';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.SUBPART_NAME IS '一级分区名称';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.PART_DATA_COUNT IS '分区数据记录数';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.PART_TBL_SIZE IS '表数据存储大小,单位以查询时的SQL为准';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.PART_IDX_SIZE IS '表索引存储大小,单位以查询时的SQL为准';
COMMENT ON COLUMN ZZY_QUERYCOUNT_LIST_TC.IF_VALID IS '是否有效，1-有效;0无效'; 
```
(2) 初始化表进行进表

```sql
-- 普通表
INSERT INTO ZZY_QUERYCOUNT_TC(TABLE_NAME ) SELECT T.TABLE_NAME FROM USER_TABLES T
WHERE 1=1  --AND T.OWNER= V_OWNER  -- DBA_TABLES 需要
AND T.TABLE_NAME NOT IN (SELECT DISTINCT TABLE_NAME FROM USER_TAB_PARTITIONS -- WHERE OWNER= V_OWNER
);
COMMIT ;
--select * from ZZY_QUERYCOUNT_TC WHERE  PART_TYPE IS NULL;

-- 分区表表
INSERT INTO ZZY_QUERYCOUNT_TC(TABLE_NAME, PART_TYPE,PART_COLUMN_NAME, SUBPART_TYPE, SUBPART_COLUMN_NAME, TOTAL_PART_COUNT )
SELECT  X.TABLE_NAME, X.PART_TYPE, X.PART_COLUMN_NAME, X.SUBPART_TYPE, X.SUBPART_COLUMN_NAME,X.PARTITION_COUNT
FROM (
    SELECT P.TABLE_NAME, P.PARTITIONING_TYPE AS  PART_TYPE, K.COLUMN_NAME AS PART_COLUMN_NAME,
        P.SUBPARTITIONING_TYPE AS SUBPART_TYPE, SK.COLUMN_NAME AS SUBPART_COLUMN_NAME, P.PARTITION_COUNT AS PARTITION_COUNT
        --,P.OWNER
    FROM USER_PART_TABLES P INNER JOIN USER_PART_KEY_COLUMNS K ON P.TABLE_NAME = K.NAME
        LEFT JOIN USER_SUBPART_KEY_COLUMNS SK ON K.NAME = SK.NAME
 ) X where 1=1 -- AND X.OWNER= V_OWNER  -- DBA_TABLES 需要
AND x.TABLE_NAME not like 'BIN%';
COMMIT ;

--select * from ZZY_QUERYCOUNT_TC WHERE  PART_TYPE IS NOT NULL;
-- 初始化分区表分区信息
INSERT INTO ZZY_QUERYCOUNT_LIST_TC(TABLE_NAME, PART_NAME, SUBPART_COUNT, SUBPART_NAME)
SELECT  T.TABLE_NAME, T.PARTITION_NAME, T.SUBPARTITION_COUNT, S.SUBPARTITION_NAME
FROM USER_TAB_PARTITIONS T LEFT JOIN USER_TAB_SUBPARTITIONS S ON T.TABLE_NAME=S.TABLE_NAME AND T.PARTITION_NAME=S.PARTITION_NAME
WHERE 1=1 --AND T.TABLE_OWNER= V_OWNER 
AND T.TABLE_NAME not like 'BIN%';
COMMIT ;
--select * from ZZY_QUERYCOUNT_LIST_TC ;
```
(3) 准备SQL脚本。根据需要调整

这里将建表和初始化也一起放进来了。

```sql
CREATE OR REPLACE PACKAGE ZZY_COUNT_PKG
IS
    PROCEDURE INIT_TABLE_CREATE;
    PROCEDURE INIT_TABLE_INFO(V_OWNER VARCHAR2);
    PROCEDURE QUERY_TABLE_COUNT;
    PROCEDURE QUERY_TABLE_SIZE(V_OWNER VARCHAR2, DBA_VIEW NUMBER DEFAULT 0);
    PROCEDURE QUERY_PART_COUNT;
    PROCEDURE QUERY_PART_SIZE(V_OWNER VARCHAR2, DBA_VIEW NUMBER DEFAULT 0);
END;
/

CREATE OR REPLACE PACKAGE body ZZY_COUNT_PKG
IS
    TYPE  CURS_TYPE IS REF CURSOR;
PROCEDURE INIT_TABLE_CREATE IS
    V_SQL1 varchar2(2000) ;
    V_SQL2 varchar2(2000) ;
BEGIN
    V_SQL1 := 'CREATE TABLE ZZY_QUERYCOUNT_TC(
    TABLE_NAME VARCHAR2(40),
    PART_TYPE VARCHAR2(20),
    PART_COLUMN_NAME VARCHAR2(40),
    SUBPART_TYPE VARCHAR2(20),
    SUBPART_COLUMN_NAME VARCHAR2(40),
    PARTITION_COUNT NUMBER(20),
    TOTAL_COUNT VARCHAR2(200),
    TBL_SIZE VARCHAR2(200),
    TBL_IDX_SIZE VARCHAR2(200),
    IF_VALID CHAR(1) DEFAULT ''1'',
    QUERY_CRITERIA VARCHAR2(200),
    VALUE1 VARCHAR2(200),
    VALUE2 VARCHAR2(200),
    LAST_OPDATE DATE DEFAULT SYSDATE,
    EXT1 VARCHAR2(500),
    EXT2 VARCHAR2(500)
);';
   EXECUTE IMMEDIATE V_SQL1;
    V_SQL2 := 'CREATE TABLE ZZY_QUERYCOUNT_LIST_TC
(
    TABLE_NAME VARCHAR2(40),
    PART_NAME VARCHAR2(20),
    SUBPART_COUNT NUMBER(20),
    SUBPART_NAME VARCHAR2(20),
    PART_DATA_COUNT VARCHAR2(200),
    PART_TBL_SIZE VARCHAR2(200),
    PART_IDX_SIZE VARCHAR2(200),
    IF_VALID CHAR(1) DEFAULT ''1'',
    LAST_OPDATE DATE DEFAULT SYSDATE,
    EXT1 VARCHAR2(500),
    EXT2 VARCHAR2(500)
);';
   EXECUTE IMMEDIATE V_SQL2;
end;

PROCEDURE INIT_TABLE_INFO(V_OWNER VARCHAR2) IS
BEGIN

    -- 普通表
    INSERT INTO ZZY_QUERYCOUNT_TC(TABLE_NAME ) SELECT T.TABLE_NAME FROM USER_TABLES T
        WHERE 1=1  --AND T.OWNER= V_OWNER  -- DBA_TABLES 需要
        AND T.TABLE_NAME NOT IN (SELECT DISTINCT TABLE_NAME FROM USER_TAB_PARTITIONS -- WHERE OWNER= V_OWNER
         );
    COMMIT ;
    --select * from ZZY_QUERYCOUNT_TC WHERE  PART_TYPE IS NULL;
    -- 分区表表
    INSERT INTO ZZY_QUERYCOUNT_TC(TABLE_NAME, PART_TYPE,PART_COLUMN_NAME, SUBPART_TYPE, SUBPART_COLUMN_NAME, TOTAL_PART_COUNT )
    SELECT  X.TABLE_NAME, X.PART_TYPE, X.PART_COLUMN_NAME, X.SUBPART_TYPE, X.SUBPART_COLUMN_NAME,X.PARTITION_COUNT
           FROM (
               SELECT P.TABLE_NAME, P.PARTITIONING_TYPE AS  PART_TYPE, K.COLUMN_NAME AS PART_COLUMN_NAME,
                      P.SUBPARTITIONING_TYPE AS SUBPART_TYPE, SK.COLUMN_NAME AS SUBPART_COLUMN_NAME, P.PARTITION_COUNT AS PARTITION_COUNT
                      --,P.OWNER
               FROM USER_PART_TABLES P INNER JOIN USER_PART_KEY_COLUMNS K ON P.TABLE_NAME = K.NAME
               LEFT JOIN USER_SUBPART_KEY_COLUMNS SK ON K.NAME = SK.NAME
            ) X where 1=1 -- AND X.OWNER= V_OWNER  -- DBA_TABLES 需要
            AND x.TABLE_NAME not like 'BIN%';
    COMMIT ;
    --select * from ZZY_QUERYCOUNT_TC WHERE  PART_TYPE IS NOT NULL;
    -- 初始化分区表分区信息
    INSERT INTO ZZY_QUERYCOUNT_LIST_TC(TABLE_NAME, PART_NAME, SUBPART_COUNT, SUBPART_NAME)
    SELECT  T.TABLE_NAME, T.PARTITION_NAME, T.SUBPARTITION_COUNT, S.SUBPARTITION_NAME
        FROM USER_TAB_PARTITIONS T LEFT JOIN USER_TAB_SUBPARTITIONS S ON T.TABLE_NAME=S.TABLE_NAME AND T.PARTITION_NAME=S.PARTITION_NAME
        WHERE 1=1 --AND T.TABLE_OWNER= V_OWNER 
        AND T.TABLE_NAME not like 'BIN%';
    COMMIT ;
    --select * from ZZY_QUERYCOUNT_LIST_TC ;
END;

PROCEDURE QUERY_TABLE_COUNT IS
    QUERY_CUR CURS_TYPE ;
    QUERYCOUNT_CUR CURS_TYPE ;
    V_QUERY_SQL VARCHAR2(2000);
    V_TABLE_NAME VARCHAR2(40);
    V_COUNT_SQL VARCHAR2(2000);
    V_TABLE_COUNT NUMBER(20);
BEGIN
    V_QUERY_SQL := 'SELECT TABLE_NAME FROM ZZY_QUERYCOUNT_TC WHERE TOTAL_COUNT IS NULL and ROWNUM < 1000  ';
    OPEN QUERY_CUR FOR V_QUERY_SQL;
    LOOP
        FETCH QUERY_CUR INTO V_TABLE_NAME ;
        EXIT WHEN QUERY_CUR%NOTFOUND;
        V_COUNT_SQL := 'SELECT COUNT(*) FROM '|| V_TABLE_NAME ;
        OPEN QUERYCOUNT_CUR FOR V_COUNT_SQL ;
        LOOP
            FETCH QUERYCOUNT_CUR INTO V_TABLE_COUNT ;
            EXIT WHEN QUERYCOUNT_CUR%NOTFOUND;
            UPDATE ZZY_QUERYCOUNT_TC Z SET Z.TOTAL_COUNT = V_TABLE_COUNT||'' WHERE TABLE_NAME = V_TABLE_NAME ;
            COMMIT ;
        END LOOP;
        close QUERYCOUNT_CUR;
    END LOOP;
    CLOSE  QUERY_CUR;
END QUERY_TABLE_COUNT;

PROCEDURE QUERY_TABLE_SIZE(V_OWNER IN VARCHAR2, DBA_VIEW NUMBER DEFAULT 0) IS
    QUERY_CUR CURS_TYPE ;
    V_QUERY_SQL VARCHAR2(2000);
    V_TABLE_NAME VARCHAR2(40);
    V_SEGMENT_TYPE VARCHAR2(2000);
    V_SIZE NUMBER(20,15); 

BEGIN
    V_QUERY_SQL := 'SELECT  O.TABLE_NAME, O.SEGMENT_TYPE, ROUND(SUM(GB), 4) AS OGB FROM (
        SELECT CASE WHEN INSTR(T.SEGMENT_TYPE, ''TABLE'') >0 THEN T.SEGMENT_NAME
                    ELSE ( SELECT I.TABLE_NAME FROM DBA_INDEXES I WHERE i.OWNER = '''||V_OWNER||''' and I.INDEX_NAME = T.SEGMENT_NAME)
                END AS TABLE_NAME,
               CASE WHEN INSTR(T.SEGMENT_TYPE, ''TABLE'') >0 THEN ''TABLE'' ELSE ''INDEX'' END AS SEGMENT_TYPE,
               T.BYTES/1024/1024/1024 AS GB';
    IF DBA_VIEW = 0 THEN       
        V_QUERY_SQL := V_QUERY_SQL || ' FROM USER_SEGMENTS T 
        WHERE 1=1 ' ;
    ELSE
           V_QUERY_SQL := V_QUERY_SQL || ' FROM DBA_SEGMENTS T 
        WHERE T.OWNER = '''||V_OWNER||''' ' ;
    END IF ;
        
    V_QUERY_SQL := V_QUERY_SQL || 'AND T.SEGMENT_TYPE IN (''TABLE'',''TABLE PARTITION'',''TABLE SUBPARTITION'',
                   ''INDEX'',''INDEX PARTITION'',''INDEX SUBPARTITION'')
        ) O
        WHERE 1=1 AND O.TABLE_NAME IN (SELECT TABLE_NAME FROM ZZY_QUERYCOUNT_TC WHERE TBL_SIZE IS NULL)
        GROUP BY O.TABLE_NAME, O.SEGMENT_TYPE
        ORDER BY O.TABLE_NAME, O.SEGMENT_TYPE DESC ';
        DBMS_OUTPUT.put_line('V_QUERY_SQL IS >> ' || V_QUERY_SQL);
    OPEN QUERY_CUR FOR V_QUERY_SQL;
    LOOP
        FETCH QUERY_CUR INTO V_TABLE_NAME, V_SEGMENT_TYPE, V_SIZE ;
        EXIT WHEN QUERY_CUR%NOTFOUND;

        IF INSTR(V_SEGMENT_TYPE, 'TABLE')>0 THEN
            UPDATE ZZY_QUERYCOUNT_TC Z SET Z.TBL_SIZE = V_SIZE||'' WHERE TABLE_NAME = V_TABLE_NAME ;
            COMMIT ;
        ELSIF INSTR(V_SEGMENT_TYPE, 'INDEX')>0 THEN
            UPDATE ZZY_QUERYCOUNT_TC Z SET Z.TBL_IDX_SIZE = V_SIZE||'' WHERE TABLE_NAME = V_TABLE_NAME ;
            COMMIT ;
        END IF;

    END LOOP;
    CLOSE  QUERY_CUR;

   
END QUERY_TABLE_SIZE;

PROCEDURE QUERY_PART_COUNT IS
    V_QUERYCOUNT_SQL VARCHAR2(2000);
    V_DATA_COUNT NUMBER(20); 

BEGIN
    /* 只统计 分区表的分区count */
    FOR CUR IN (SELECT T.TABLE_NAME, T.PART_NAME,T.SUBPART_NAME,T.SUBPART_COUNT  FROM ZZY_QUERYCOUNT_LIST_TC T WHERE  PART_DATA_COUNT IS NULL )
        LOOP
        V_DATA_COUNT := 0 ;
        IF CUR.SUBPART_COUNT = 0 THEN
            V_QUERYCOUNT_SQL := 'SELECT COUNT(*) FROM '||CUR.TABLE_NAME||' PARTITION('||CUR.PART_NAME||') ';
            DBMS_OUTPUT.put_line('V_QUERYCOUNT_SQL IS >> ' || V_QUERYCOUNT_SQL);
            EXECUTE IMMEDIATE V_QUERYCOUNT_SQL INTO V_DATA_COUNT ;
            DBMS_OUTPUT.put_line('V_DATA_COUNT IS >> ' || V_DATA_COUNT);
            UPDATE ZZY_QUERYCOUNT_LIST_TC Q SET Q.PART_DATA_COUNT = V_DATA_COUNT ||'' 
                WHERE Q.TABLE_NAME = CUR.TABLE_NAME AND Q.PART_NAME = CUR.PART_NAME ;
            COMMIT ;
        ELSIF CUR.SUBPART_COUNT > 0 THEN
            V_QUERYCOUNT_SQL := 'SELECT COUNT(*) FROM '||CUR.TABLE_NAME||' SUBPARTITION('||CUR.SUBPART_NAME||') ';
            DBMS_OUTPUT.put_line('SUBPART COUNT >> V_QUERYCOUNT_SQL IS >> ' || V_QUERYCOUNT_SQL);
            EXECUTE IMMEDIATE V_QUERYCOUNT_SQL INTO V_DATA_COUNT ;
            DBMS_OUTPUT.put_line('SUBPART COUNT >> V_DATA_COUNT IS >> ' || V_DATA_COUNT);
            
            UPDATE ZZY_QUERYCOUNT_LIST_TC Q SET Q.PART_DATA_COUNT = V_DATA_COUNT ||''   
                WHERE Q.TABLE_NAME = CUR.TABLE_NAME AND Q.PART_NAME = CUR.PART_NAME AND Q.SUBPART_NAME = CUR.SUBPART_NAME ;
            COMMIT ;
        END IF;
        

     END LOOP;
END QUERY_PART_COUNT;


PROCEDURE QUERY_PART_SIZE(V_OWNER IN VARCHAR2, DBA_VIEW NUMBER DEFAULT 0) IS
    QUERYSIZE_CUR CURS_TYPE ;
    V_QUERYSIZE_SQL VARCHAR2(2000);
    V_TABLE_NAME NUMBER(20);
    V_SEGMENT_TYPE NUMBER(20,15);
    V_SIZE NUMBER(20,15);
    V_TABLE_SIZE NUMBER(20,15) := 0;
    V_INDEX_SIZE NUMBER(20,15) := 0 ;

BEGIN
    /* 只统计 分区表的分区存储 */
    FOR CUR IN (SELECT T.TABLE_NAME, T.PART_NAME,T.SUBPART_NAME,T.SUBPART_COUNT  FROM ZZY_QUERYCOUNT_LIST_TC T 
      WHERE  PART_TBL_SIZE IS NULL OR PART_IDX_SIZE IS NULL )
    LOOP

       V_QUERYSIZE_SQL := 'SELECT  O.TABLE_NAME, O.SEGMENT_TYPE,  ROUND(SUM(GB), 4) AS OGB FROM (
SELECT CASE WHEN INSTR(T.SEGMENT_TYPE, ''TABLE'') >0 THEN T.SEGMENT_NAME
            ELSE ( SELECT I.TABLE_NAME FROM DBA_INDEXES I WHERE I.INDEX_NAME = T.SEGMENT_NAME)
        END AS TABLE_NAME,
       CASE WHEN INSTR(T.SEGMENT_TYPE, ''TABLE'') >0 THEN ''TABLE'' ELSE ''INDEX'' END AS SEGMENT_TYPE,
       T.PARTITION_NAME,
       T.BYTES/1024/1024/1024 AS GB ' ;
       
       IF DBA_VIEW = 0 THEN       
          V_QUERYSIZE_SQL := V_QUERYSIZE_SQL || ' FROM USER_SEGMENTS T 
WHERE 1=1 ' ;
       ELSE
          V_QUERYSIZE_SQL := V_QUERYSIZE_SQL || ' FROM DBA_SEGMENTS T 
WHERE T.OWNER = '''||V_OWNER||''' ' ;
      END IF ;
    
        V_QUERYSIZE_SQL := V_QUERYSIZE_SQL || ' 
AND (  t.SEGMENT_NAME = '''||CUR.TABLE_NAME||''' OR T.SEGMENT_NAME IN (
        SELECT D.INDEX_NAME FROM DBA_INDEXES D WHERE D.TABLE_NAME = '''||CUR.TABLE_NAME||''' )
    )
AND PARTITION_NAME = '''||CUR.PART_NAME||'''
AND T.SEGMENT_NAME NOT LIKE ''BIN%''
AND T.SEGMENT_TYPE IN (''TABLE'',''TABLE PARTITION'',''TABLE SUBPARTITION'',''INDEX'',''INDEX PARTITION'',''INDEX SUBPARTITION'')
) O
GROUP BY O.TABLE_NAME, O.SEGMENT_TYPE, O.PARTITION_NAME
ORDER BY O.TABLE_NAME, O.SEGMENT_TYPE DESC, O.PARTITION_NAME';

    DBMS_OUTPUT.put_line('V_QUERYSIZE_SQL IS >> ' || V_QUERYSIZE_SQL);
    OPEN QUERYSIZE_CUR FOR V_QUERYSIZE_SQL ;
    LOOP
            FETCH QUERYSIZE_CUR INTO V_TABLE_NAME, V_SEGMENT_TYPE, V_SIZE ;
            EXIT WHEN QUERYSIZE_CUR%NOTFOUND;

            IF INSTR(V_SEGMENT_TYPE, 'TABLE')>0 THEN
                V_TABLE_SIZE := V_SIZE  ;
            ELSIF INSTR(V_SEGMENT_TYPE, 'INDEX')>0 THEN
                V_INDEX_SIZE := V_SIZE ;
            END IF;
    END LOOP;
        CLOSE QUERYSIZE_CUR ;

        UPDATE ZZY_QUERYCOUNT_LIST_TC Q SET  Q.PART_TBL_SIZE = V_TABLE_SIZE, Q.PART_IDX_SIZE = V_INDEX_SIZE
            WHERE Q.TABLE_NAME = CUR.TABLE_NAME AND Q.PART_NAME = CUR.PART_NAME ;
        COMMIT ;
     END LOOP;
END QUERY_PART_SIZE;

BEGIN
    NULL;
END;
/
```

### 工具函数

（1）字符串分割成集合，可用来循环使用
```sql
CREATE OR REPLACE TYPE TY_STR_SPLIT AS TABLE OF VARCHAR(4000);
 
-- 字符串分割返回集合
CREATE FUNCTION FN_SPLIT(P_STR IN VARCHAR2, P_DELIMITER IN VARCHAR2) RETURN  TY_STR_SPLIT IS
    L_RESULT TY_STR_SPLIT := TY_STR_SPLIT();
    L_START    INTEGER   := 1 ;
    L_DELIM_LENGHT  INTEGER  := length(P_DELIMITER) ;
    L_SUBSTR  INTEGER := 0 ;
BEGIN
    IF P_STR IS NULL OR P_DELIMITER IS NULL THEN
        RETURN L_RESULT;
    end if;
    WHILE L_START < LENGTH(P_STR) LOOP
            L_SUBSTR := INSTR(P_STR, P_DELIMITER, L_START);
            IF L_SUBSTR = 0 THEN
                L_RESULT.extend(1);
                L_RESULT(L_RESULT.LAST) := SUBSTR(P_STR, L_START);
                L_START := LENGTH(P_STR) +1;
            ELSE
                L_RESULT.extend(1);
                L_RESULT(L_RESULT.LAST) := SUBSTR(P_STR, L_START, L_SUBSTR - L_START);
                L_START:= L_SUBSTR + L_DELIM_LENGHT;
             END IF;
        END LOOP;
    RETURN L_RESULT;
END FN_SPLIT;
/


```

使用示例
```sql
-- 测试
SELECT FN_SPLIT('1-2-3-4','-')
FROM DUAL;
```

（3）休眠函数

```sql
-- 休眠函数
CREATE OR REPLACE FUNCTION SLEEP(SECONDS IN NUMBER) RETURN NUMBER IS
    START_TIME   NUMBER;
    ELASPED_TIME NUMBER;
BEGIN
    START_TIME := DBMS_UTILITY.GET_TIME();
    ELASPED_TIME := 0;
    LOOP
        ELASPED_TIME := (DBMS_UTILITY.GET_TIME() - START_TIME) / 100;
        EXIT WHEN ELASPED_TIME >= SECONDS;
    END LOOP;
    RETURN 0;
END;
/
```
使用案例

方式一: 在SELECT查询中使用

```sql
DECLARE
    V_TIME NUMBER;
BEGIN
SELECT SLEEP(3) INTO  V_TIME FROM DUAL;

END;
```

方式二：直接当成函数调用，使用返回值接收结果

```sql
DECLARE 
    V_TIME NUMBER;
BEGIN
V_TIME := SLEEP(3);

END;
```

（3）LONG 转 CHAR

```sql
-- ORACLE LONG 转 CHAR 函数
CREATE OR REPLACE FUNCTION LONG_TO_CHAR(
    IN_COLUMN_NAME VARCHAR2,
    IN_OWNER VARCHAR2,
    IN_INDEX_NAME VARCHAR2,
    IN_CONDITION VARCHAR2
)
    RETURN VARCHAR AS
    TEXT_STR VARCHAR2(32767);
    SQL_STR  VARCHAR2(2000);
BEGIN
    SQL_STR := 'SELECT ' || IN_COLUMN_NAME || ' FROM ' || IN_OWNER || '.' || IN_INDEX_NAME ||
               ' T WHERE 1=1 ' || IN_CONDITION;
    EXECUTE IMMEDIATE SQL_STR INTO TEXT_STR;
    TEXT_STR := SUBSTR(TEXT_STR, 1, 32767);
    RETURN TEXT_STR;
END;
/


CREATE OR REPLACE FUNCTION INDEX_COLUMN_EXPRESSION(
    IN_TABLE_NAME VARCHAR2,
    IN_INDEX_NAME VARCHAR2,
    IN_COLUMN_POSITION VARCHAR2
)
    RETURN VARCHAR AS
    TEXT_STR VARCHAR2(32767);
    SQL_STR  VARCHAR2(2000);
BEGIN
    SQL_STR := 'SELECT COLUMN_EXPRESSION
        FROM USER_IND_EXPRESSIONS T WHERE T.TABLE_NAME =''' || IN_TABLE_NAME || '''
        AND T.INDEX_NAME = ''' || IN_INDEX_NAME || '''
        AND T.COLUMN_POSITION = ''' || IN_COLUMN_POSITION || ''' ';
    EXECUTE IMMEDIATE SQL_STR INTO TEXT_STR;
    TEXT_STR := SUBSTR(TEXT_STR, 1, 4000);
    RETURN TEXT_STR;
END;
/
```

LONG_TO_CHAR函数使用案例

```sql
SELECT E.TABLE_NAME,
       E.INDEX_NAME,
       INDEX_COLUMN_EXPRESSION(E.TABLE_NAME, E.INDEX_NAME, E.COLUMN_POSITION) AS COLUMN_EXPRESSION
FROM USER_IND_EXPRESSIONS E;
```

INDEX_COLUMN_EXPRESSION函数使用案例

```sql
SELECT E.TABLE_NAME,
       E.INDEX_NAME,
       INDEX_COLUMN_EXPRESSION(E.TABLE_NAME, E.INDEX_NAME, E.COLUMN_POSITION) AS COLUMN_EXPRESSION
FROM USER_IND_EXPRESSIONS E;
```
